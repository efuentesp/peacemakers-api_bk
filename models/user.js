// Generated by CoffeeScript 1.6.3
var PermissionSchema, RoleSchema, Schema, UserSchema, async, crypto, mongoose, resolvePermission, resolveRole;

mongoose = require('mongoose');

crypto = require('crypto');

async = require('async');

Schema = mongoose.Schema;

PermissionSchema = new Schema({
  subject: {
    type: String,
    "default": ''
  },
  action: {
    type: String,
    "default": ''
  },
  displayName: String,
  description: String
});

mongoose.model('Permission', PermissionSchema);

resolvePermission = function(permission, done) {
  return mongoose.model('Permission').findOne({
    subject: permission.subject,
    action: permission.action
  }, function(err, permission) {
    if (err) {
      return done(err);
    }
    if (!permission) {
      return done(new Error("Unknown Permission: " + permission));
    }
    return done(null, permission);
  });
};

RoleSchema = new Schema({
  name: {
    type: String,
    "default": ''
  },
  displayName: String,
  description: String,
  permissions: [
    {
      type: Schema.ObjectId,
      ref: 'Permission'
    }
  ]
});

RoleSchema.methods = {
  hasPermission: function(permissionId) {
    var p, _i, _len, _ref;
    if (this.permissions) {
      _ref = this.permissions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (permissionId.toString() === p.toString()) {
          return true;
        }
      }
    }
    return false;
  },
  addPermission: function(p, done) {
    var _this = this;
    return resolvePermission(p, function(err, permission) {
      if (err) {
        return done(err);
      }
      if (_this.hasPermission(permission._id)) {
        return done(new Error("Existing Permission: " + permission.subject + " " + permission.action));
      }
      _this.permissions.push({
        _id: permission._id
      });
      return done();
    });
  }
};

mongoose.model('Role', RoleSchema);

resolveRole = function(roleName, done) {
  return mongoose.model('Role').findOne({
    name: roleName
  }, function(err, role) {
    if (err) {
      return done(err);
    }
    if (!role) {
      return done(new Error("Unknown Role: " + roleName));
    }
    return done(null, role);
  });
};

UserSchema = new Schema({
  username: {
    type: String,
    "default": ''
  },
  hashed_password: {
    type: String,
    "default": ''
  },
  email: {
    type: String,
    "default": ''
  },
  authToken: {
    type: String,
    "default": ''
  },
  salt: {
    type: String,
    "default": ''
  },
  roles: [
    {
      type: Schema.ObjectId,
      ref: 'Role'
    }
  ]
});

UserSchema.virtual('password').set(function(password) {
  this._password = password;
  this.salt = this.makeSalt();
  return this.hashed_password = this.encryptPassword(password);
}).get(function() {
  return this._password;
});

UserSchema.methods = {
  authenticate: function(plainText) {
    return this.encryptPassword(plainText) === this.hashed_password;
  },
  validateToken: function(token, tokenDecoded) {
    var now;
    if (token !== this.authToken) {
      return false;
    }
    now = Math.round(new Date().getTime() / 1000);
    return tokenDecoded.expires > now;
  },
  makeSalt: function() {
    return Math.round(new Date().valueOf() * Math.random()) + '';
  },
  encryptPassword: function(password) {
    var encrypred, err;
    if (!password) {
      return '';
    }
    try {
      encrypred = crypto.createHmac('sha1', this.salt).update(password).digest('hex');
      return encrypred;
    } catch (_error) {
      err = _error;
      return '';
    }
  },
  hasRole: function(roleId) {
    var r, _i, _len, _ref;
    if (this.roles) {
      _ref = this.roles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (roleId.toString() === r.toString()) {
          return true;
        }
      }
    }
    return false;
  },
  addRole: function(roleName, done) {
    var _this = this;
    return resolveRole(roleName, function(err, role) {
      if (err) {
        return done(err);
      }
      if (_this.hasRole(role._id)) {
        return done(new Error("Existing Role: " + roleName));
      }
      _this.roles.push({
        _id: role._id
      });
      return done();
    });
  },
  getPermissions: function(done) {
    var loopPermissions, loopRoles, permissions;
    permissions = [];
    loopPermissions = function(p, done) {
      return mongoose.model('Permission').findById(p, function(err, permission) {
        if (err) {
          return done(err);
        }
        permissions.push({
          subject: permission.subject,
          action: permission.action
        });
        return done();
      });
    };
    loopRoles = function(r, done) {
      return mongoose.model('Role').findById(r, function(err, role) {
        if (err) {
          return done(err);
        }
        if (role.permissions) {
          return async.each(role.permissions, loopPermissions, function(err) {
            if (err) {
              done(err);
            }
            return done();
          });
        } else {
          return done();
        }
      });
    };
    if (this.roles) {
      return async.each(this.roles, loopRoles, function(err) {
        if (err) {
          return done(err);
        }
        return done(null, permissions);
      });
    } else {
      return done(null, permissions);
    }
  },
  can: function(subject, action, done) {
    var findPermission, isAuthorized;
    isAuthorized = false;
    findPermission = function(p, done) {
      if (p.subject === subject && p.action === action) {
        isAuthorized = true;
      }
      return done();
    };
    if (this.roles) {
      return this.getPermissions(function(err, permissions) {
        return async.each(permissions, findPermission, function() {
          return done(null, isAuthorized);
        });
      });
    } else {
      return done(null, isAuthorized);
    }
  }
};

mongoose.model('User', UserSchema);
